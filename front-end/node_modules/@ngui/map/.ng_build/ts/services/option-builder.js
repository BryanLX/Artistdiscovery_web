import { Injectable } from '@angular/core';
import { getJSON } from './util';
/**
 * change any object to google object options
 * e.g. [1,2] -> new google.maps.LatLng(1,2);
 */
export class OptionBuilder {
    /**
     * @param {?} definedInputs
     * @param {?} userInputs
     * @return {?}
     */
    googlizeAllInputs(definedInputs, userInputs) {
        let /** @type {?} */ options = {};
        // if options given from user, only take options and ignore other inputs
        if (userInputs.options) {
            console.log('userInputs.options .................', userInputs.options);
            options = userInputs.options;
            if (!this.onlyOptionsGiven(definedInputs, userInputs)) {
                console.error('when "options" are used, other options are ignored');
            }
        }
        else {
            definedInputs.forEach(input => {
                if (userInputs[input] !== undefined) {
                    options[input] = this.googlize(userInputs[input], { key: input });
                }
            });
        }
        return options;
    }
    /**
     * @param {?} inputs
     * @param {?=} options
     * @return {?}
     */
    googlizeMultiple(inputs, options) {
        options = options || {};
        for (let /** @type {?} */ key in inputs) {
            let /** @type {?} */ val = inputs[key];
            // (non-strings are fully converted)
            if (typeof val !== 'string') {
                options[key] = val;
            } // sometimes '0' needed to stay as it is
            else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {
                options[key] = this.googlize(val, { key: key });
            }
        } // for(var key in attrs)
        return options;
    }
    /**
     * @param {?} input
     * @param {?=} options
     * @return {?}
     */
    googlize(input, options) {
        options = options || {};
        let /** @type {?} */ output = input;
        if (typeof input === 'string') {
            if (input === 'false') {
                output = false;
            }
            else if (input === '0') {
                output = 0;
            }
            else {
                output =
                    // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed
                    this.getJSONParsed(input, options)
                        /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */
                        || this.getAnyMapObject(input)
                        /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */
                        || this.getAnyMapConstant(input, options)
                        /*  2016-06-20 -> new Date('2016-06-20') */
                        || this.getDateObject(input)
                        || input;
            }
        }
        if (options['key']) {
            let /** @type {?} */ key = (options['key']);
            if (output instanceof Array) {
                if (key === 'bounds') {
                    output = new google.maps.LatLngBounds(output[0], output[1]);
                }
                else if (key === 'icons') {
                    output = this.getMapIcons(output);
                }
                else if (key === 'position' || key.match(/^geoFallback/)) {
                    output = this.getLatLng(output);
                }
            }
            else if (output instanceof Object) {
                if (key === 'icon') {
                    output = this.getMarkerIcon(output);
                }
                else if (key.match(/ControlOptions$/)) {
                    output = this.getMapControlOption(output);
                }
            }
        }
        // delete keys only for processing, not used by google
        delete output['doNotConverStringToNumber'];
        delete output['key'];
        return output;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    getLatLng(input) {
        let /** @type {?} */ output;
        if (input[0].constructor === Array) {
            output = ((input)).map((el) => new google.maps.LatLng(el[0], el[1]));
        }
        else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {
            output = new google.maps.LatLng(input[0], input[1]);
        }
        return output;
    }
    /**
     * @param {?} input
     * @param {?} options
     * @return {?}
     */
    getJSONParsed(input, options) {
        let /** @type {?} */ output;
        try {
            output = getJSON(input);
            if (output instanceof Array) {
                // [{a:1}] : not lat/lng ones
                if (output[0].constructor !== Object) {
                    output = this.getLatLng(output);
                }
            }
            else if (output === Object(output)) {
                // check for nested hashes and convert to Google API options
                let /** @type {?} */ newOptions = options;
                newOptions['doNotConverStringToNumber'] = true;
                output = this.googlizeMultiple(output, newOptions);
            }
        }
        catch (e) {
        }
        return output;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    getAnyMapObject(input) {
        let /** @type {?} */ output;
        if (input.match(/^[A-Z][a-zA-Z0-9]+\(.*\)$/)) {
            try {
                output = Function(`return new google.maps.${input};`)();
            }
            catch (e) { }
        }
        return output;
    }
    /**
     * @param {?} input
     * @param {?} options
     * @return {?}
     */
    getAnyMapConstant(input, options) {
        let /** @type {?} */ output;
        if (input.match(/^([A-Z][a-zA-Z0-9]+)\.([A-Z]+)$/)) {
            try {
                let /** @type {?} */ matches = input.match(/^([A-Z][a-zA-Z0-9]+)\.([A-Z]+)$/);
                output = google.maps[matches[1]][matches[2]];
            }
            catch (e) { }
        }
        else if (input.match(/^[A-Z]+$/)) {
            try {
                let /** @type {?} */ capitalizedKey = ((options['key'])).charAt(0).toUpperCase() +
                    ((options['key'])).slice(1);
                output = google.maps[capitalizedKey][input];
            }
            catch (e) { }
        }
        return output;
    }
    /**
     * streetviewControl, panControl, etc, not a general control
     * @param {?} controlOptions
     * @return {?}
     */
    getMapControlOption(controlOptions) {
        let /** @type {?} */ newControlOptions = controlOptions;
        for (let /** @type {?} */ key in newControlOptions) {
            if (newControlOptions[key]) {
                let /** @type {?} */ value = newControlOptions[key];
                if (typeof value === 'string') {
                    value = ((value)).toUpperCase();
                }
                else if (key === 'mapTypeIds') {
                    value = ((value)).map(function (str) {
                        if (str.match(/^[A-Z]+$/)) {
                            return google.maps.MapTypeId[str.toUpperCase()];
                        }
                        else {
                            return str;
                        }
                    });
                }
                if (key === 'style') {
                    let /** @type {?} */ objName = key.replace(/Options$/, '') + 'Style';
                    newControlOptions[key] = google.maps[objName][(value)];
                }
                else if (key === 'position') {
                    newControlOptions[key] = google.maps.ControlPosition[(value)];
                }
                else {
                    newControlOptions[key] = value;
                }
            }
        }
        return newControlOptions;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    getDateObject(input) {
        let /** @type {?} */ output;
        if (input.match(/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*)?)([zZ]|([+\-])(\d\d):?(\d\d))?$/)) {
            try {
                output = new Date(input);
            }
            catch (e) { }
        }
        return output;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    getMapIcons(input) {
        return input.map(el => {
            if (el.icon.path.match(/^[A-Z_]+$/)) {
                el.icon.path = google.maps.SymbolPath[el.icon.path];
            }
            return el;
        });
    }
    /**
     * @param {?} input
     * @return {?}
     */
    getMarkerIcon(input) {
        let /** @type {?} */ output = input;
        if (('' + output.path).match(/^[A-Z_]+$/)) {
            output.path = google.maps.SymbolPath[output.path];
        }
        for (let /** @type {?} */ key in output) {
            let /** @type {?} */ arr = output[key];
            if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {
                output[key] = new google.maps.Point(arr[0], arr[1]);
            }
            else if (key === 'size' || key === 'scaledSize') {
                output[key] = new google.maps.Size(arr[0], arr[1]);
            }
        }
        return output;
    }
    /**
     * @param {?} definedInputs
     * @param {?} userInputs
     * @return {?}
     */
    onlyOptionsGiven(definedInputs, userInputs) {
        for (let /** @type {?} */ i = 0; i < definedInputs.length; i++) {
            let /** @type {?} */ input = definedInputs[i];
            if (input !== 'options' && typeof userInputs[input] !== 'undefined') {
                return false;
            }
        }
        return true;
    }
}
OptionBuilder.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
OptionBuilder.ctorParameters = () => [];
function OptionBuilder_tsickle_Closure_declarations() {
    /** @type {?} */
    OptionBuilder.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    OptionBuilder.ctorParameters;
}
//# sourceMappingURL=option-builder.js.map