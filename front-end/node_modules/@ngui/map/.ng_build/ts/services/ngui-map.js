import { Injectable, NgZone } from '@angular/core';
import { OptionBuilder } from './option-builder';
import { GeoCoder } from './geo-coder';
/**
 * collection of map instance-related properties and methods
 */
export class NguiMap {
    /**
     * @param {?} geoCoder
     * @param {?} optionBuilder
     * @param {?} zone
     */
    constructor(geoCoder, optionBuilder, zone) {
        this.geoCoder = geoCoder;
        this.optionBuilder = optionBuilder;
        this.zone = zone;
        this.updateGoogleObject = (object, changes) => {
            let /** @type {?} */ val, /** @type {?} */ currentValue, /** @type {?} */ setMethodName;
            if (object) {
                for (let /** @type {?} */ key in changes) {
                    setMethodName = `set${key.replace(/^[a-z]/, x => x.toUpperCase())}`;
                    currentValue = changes[key].currentValue;
                    if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {
                        // To preserve setMethod name in Observable callback, wrap it as a function, then execute
                        ((setMethodName) => {
                            this.geoCoder.geocode({ address: currentValue }).subscribe(results => {
                                if (typeof object[setMethodName] === 'function') {
                                    object[setMethodName](results[0].geometry.location);
                                }
                                else {
                                    console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\n' +
                                        'Please check Google Maps API documentation, and use "setOptions" instead.');
                                }
                            });
                        })(setMethodName);
                    }
                    else {
                        val = this.optionBuilder.googlize(currentValue);
                        if (typeof object[setMethodName] === 'function') {
                            object[setMethodName](val);
                        }
                        else {
                            console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\n' +
                                'Please check Google Maps API documentation, and use "setOptions" instead.');
                        }
                    }
                }
            }
        };
    }
    /**
     * @param {?} definedEvents
     * @param {?} thisObj
     * @param {?} prefix
     * @return {?}
     */
    setObjectEvents(definedEvents, thisObj, prefix) {
        definedEvents.forEach(definedEvent => {
            let /** @type {?} */ eventName = definedEvent
                .replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`) // positionChanged -> position_changed
                .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts
            let /** @type {?} */ zone = this.zone;
            zone.runOutsideAngular(() => {
                thisObj[prefix].addListener(eventName, function (event) {
                    let /** @type {?} */ param = event ? event : {};
                    param.target = this;
                    zone.run(() => thisObj[definedEvent].emit(param));
                });
            });
        });
    }
    /**
     * @param {?} definedEvents
     * @param {?} thisObj
     * @param {?} prefix
     * @return {?}
     */
    clearObjectEvents(definedEvents, thisObj, prefix) {
        definedEvents.forEach(definedEvent => {
            let /** @type {?} */ eventName = definedEvent
                .replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`) // positionChanged -> position_changed
                .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts
            this.zone.runOutsideAngular(() => {
                if (thisObj[prefix]) {
                    google.maps.event.clearListeners(thisObj[prefix], eventName);
                }
            });
        });
        if (thisObj[prefix]) {
            if (thisObj[prefix].setMap) {
                thisObj[prefix].setMap(null);
            }
            delete thisObj[prefix].nguiMapComponent;
            delete thisObj[prefix];
        }
    }
}
NguiMap.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
NguiMap.ctorParameters = () => [
    { type: GeoCoder, },
    { type: OptionBuilder, },
    { type: NgZone, },
];
function NguiMap_tsickle_Closure_declarations() {
    /** @type {?} */
    NguiMap.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    NguiMap.ctorParameters;
    /** @type {?} */
    NguiMap.prototype.updateGoogleObject;
    /** @type {?} */
    NguiMap.prototype.geoCoder;
    /** @type {?} */
    NguiMap.prototype.optionBuilder;
    /** @type {?} */
    NguiMap.prototype.zone;
}
//# sourceMappingURL=ngui-map.js.map