import { Component, ElementRef, Output, EventEmitter, } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { debounceTime } from 'rxjs/operator/debounceTime';
import { NguiMap } from '../services/ngui-map';
import { NguiMapComponent } from './ngui-map.component';
const /** @type {?} */ INPUTS = [
    'position'
];
// to avoid DOM event conflicts map_*
const /** @type {?} */ OUTPUTS = [
    'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',
    'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',
    'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged',
    'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'
];
/**
 * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.
 * Otherwise throws a google is unknown error.
 * @param {?} htmlEl
 * @param {?} position
 * @return {?}
 */
function getCustomMarkerOverlayView(htmlEl, position) {
    class CustomMarkerOverlayView extends google.maps.OverlayView {
        /**
         * @param {?} htmlEl
         * @param {?} position
         */
        constructor(htmlEl, position) {
            super();
            this.visible = true;
            this.setPosition = (position) => {
                this.htmlEl.style.visibility = 'hidden';
                if (position.constructor.name === 'Array') {
                    this.position = new google.maps.LatLng(position[0], position[1]);
                }
                else if (typeof position === 'string') {
                    let /** @type {?} */ geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ address: position }, (results, status) => {
                        if (status === google.maps.GeocoderStatus.OK) {
                            this.setPosition(results[0].geometry.location);
                        }
                        else {
                        }
                    });
                }
                else if (position && typeof position.lng === 'function') {
                    this.position = position;
                }
                if (this.getProjection() && typeof this.position.lng === 'function') {
                    let /** @type {?} */ positionOnMap = () => {
                        let /** @type {?} */ posPixel = this.getProjection().fromLatLngToDivPixel(this.position);
                        let /** @type {?} */ x = Math.round(posPixel.x - (this.htmlEl.offsetWidth / 2));
                        let /** @type {?} */ y = Math.round(posPixel.y - this.htmlEl.offsetHeight / 2);
                        this.htmlEl.style.left = x + 'px';
                        this.htmlEl.style.top = y + 'px';
                        this.htmlEl.style.visibility = 'visible';
                    };
                    if (this.htmlEl.offsetWidth && this.htmlEl.offsetHeight) {
                        positionOnMap();
                    }
                    else {
                        setTimeout(() => positionOnMap());
                    }
                }
            };
            this.htmlEl = htmlEl;
            this.position = position;
        }
        /**
         * @return {?}
         */
        onAdd() {
            this.getPanes().overlayMouseTarget.appendChild(this.htmlEl);
            // required for correct display inside google maps container
            this.htmlEl.style.position = 'absolute';
        }
        /**
         * @return {?}
         */
        draw() {
            this.setPosition(this.position);
            this.setZIndex(this.zIndex);
            this.setVisible(this.visible);
        }
        /**
         * @return {?}
         */
        onRemove() {
            //
        }
        /**
         * @return {?}
         */
        getPosition() {
            return this.position;
        }
        /**
         * @param {?} zIndex
         * @return {?}
         */
        setZIndex(zIndex) {
            zIndex && (this.zIndex = zIndex); /* jshint ignore:line */
            this.htmlEl.style.zIndex = this.zIndex;
        }
        /**
         * @param {?} visible
         * @return {?}
         */
        setVisible(visible) {
            this.htmlEl.style.display = visible ? 'inline-block' : 'none';
            this.visible = visible;
        }
    }
    function CustomMarkerOverlayView_tsickle_Closure_declarations() {
        /** @type {?} */
        CustomMarkerOverlayView.prototype.htmlEl;
        /** @type {?} */
        CustomMarkerOverlayView.prototype.position;
        /** @type {?} */
        CustomMarkerOverlayView.prototype.zIndex;
        /** @type {?} */
        CustomMarkerOverlayView.prototype.visible;
        /** @type {?} */
        CustomMarkerOverlayView.prototype.setPosition;
    }
    return new CustomMarkerOverlayView(htmlEl, position);
}
export class CustomMarker {
    /**
     * @param {?} nguiMapComponent
     * @param {?} elementRef
     * @param {?} nguiMap
     */
    constructor(nguiMapComponent, elementRef, nguiMap) {
        this.nguiMapComponent = nguiMapComponent;
        this.elementRef = elementRef;
        this.nguiMap = nguiMap;
        this.initialized$ = new EventEmitter();
        this.inputChanges$ = new Subject();
        this.elementRef.nativeElement.style.display = 'none';
        OUTPUTS.forEach(output => this[output] = new EventEmitter());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.nguiMapComponent.mapIdledOnce) {
            this.initialize();
        }
        else {
            this.nguiMapComponent.mapReady$.subscribe(map => this.initialize());
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.inputChanges$.next(changes);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.inputChanges$.complete();
        this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);
        if (this.mapObject) {
            this.nguiMap.clearObjectEvents(OUTPUTS, this, 'mapObject');
        }
    }
    /**
     * @return {?}
     */
    initialize() {
        this.el = this.elementRef.nativeElement;
        this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);
        this.mapObject.setMap(this.nguiMapComponent.map);
        // set google events listeners and emits to this outputs listeners
        this.nguiMap.setObjectEvents(OUTPUTS, this, 'mapObject');
        // update object when input changes
        debounceTime.call(this.inputChanges$, 1000)
            .subscribe((changes) => this.nguiMap.updateGoogleObject(this.mapObject, changes));
        this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);
        this.initialized$.emit(this.mapObject);
    }
}
CustomMarker.decorators = [
    { type: Component, args: [{
                selector: 'ngui-map > custom-marker',
                inputs: INPUTS,
                outputs: OUTPUTS,
                template: `
    <ng-content></ng-content>
  `,
            },] },
];
/**
 * @nocollapse
 */
CustomMarker.ctorParameters = () => [
    { type: NguiMapComponent, },
    { type: ElementRef, },
    { type: NguiMap, },
];
CustomMarker.propDecorators = {
    'initialized$': [{ type: Output },],
};
function CustomMarker_tsickle_Closure_declarations() {
    /** @type {?} */
    CustomMarker.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    CustomMarker.ctorParameters;
    /** @type {?} */
    CustomMarker.propDecorators;
    /** @type {?} */
    CustomMarker.prototype.position;
    /** @type {?} */
    CustomMarker.prototype.animationChanged;
    /** @type {?} */
    CustomMarker.prototype.click;
    /** @type {?} */
    CustomMarker.prototype.clickableChanged;
    /** @type {?} */
    CustomMarker.prototype.cursorChanged;
    /** @type {?} */
    CustomMarker.prototype.dblclick;
    /** @type {?} */
    CustomMarker.prototype.drag;
    /** @type {?} */
    CustomMarker.prototype.dragend;
    /** @type {?} */
    CustomMarker.prototype.draggableChanged;
    /** @type {?} */
    CustomMarker.prototype.dragstart;
    /** @type {?} */
    CustomMarker.prototype.flatChanged;
    /** @type {?} */
    CustomMarker.prototype.iconChanged;
    /** @type {?} */
    CustomMarker.prototype.mousedown;
    /** @type {?} */
    CustomMarker.prototype.mouseout;
    /** @type {?} */
    CustomMarker.prototype.mouseover;
    /** @type {?} */
    CustomMarker.prototype.mouseup;
    /** @type {?} */
    CustomMarker.prototype.positionChanged;
    /** @type {?} */
    CustomMarker.prototype.rightclick;
    /** @type {?} */
    CustomMarker.prototype.shapeChanged;
    /** @type {?} */
    CustomMarker.prototype.titleChanged;
    /** @type {?} */
    CustomMarker.prototype.visibleChanged;
    /** @type {?} */
    CustomMarker.prototype.zindexChanged;
    /** @type {?} */
    CustomMarker.prototype.map_click;
    /** @type {?} */
    CustomMarker.prototype.map_mouseover;
    /** @type {?} */
    CustomMarker.prototype.map_mouseout;
    /** @type {?} */
    CustomMarker.prototype.map_mouseup;
    /** @type {?} */
    CustomMarker.prototype.map_mousedown;
    /** @type {?} */
    CustomMarker.prototype.map_drag;
    /** @type {?} */
    CustomMarker.prototype.map_dragend;
    /** @type {?} */
    CustomMarker.prototype.initialized$;
    /** @type {?} */
    CustomMarker.prototype.inputChanges$;
    /** @type {?} */
    CustomMarker.prototype.el;
    /** @type {?} */
    CustomMarker.prototype.mapObject;
    /** @type {?} */
    CustomMarker.prototype.nguiMapComponent;
    /** @type {?} */
    CustomMarker.prototype.elementRef;
    /** @type {?} */
    CustomMarker.prototype.nguiMap;
}
//# sourceMappingURL=custom-marker.js.map